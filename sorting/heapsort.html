<!DOCTYPE html><html><head><title>Computer Science Foundations</title><link rel="stylesheet" href="/cs-foundations/stylesheets/style.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><link rel="stylesheet" href="/cs-foundations/highlightjs/styles/github.css"><script src="/cs-foundations/highlightjs/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><a class="header-title" href="/cs-foundations/index.html">Computer Science Foundations</a></div><div class="collapse navbar-collapse" id="navbar"><ul class="nav navbar-nav"><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Basics <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="/cs-foundations/basics/complexity.html">Complexity Theory</a></li><li><a href="/cs-foundations/basics/heap-stack.html">Heap / Stack</a></li></ul></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Data Structures <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="/cs-foundations/structures/linked-list.html">Linked List</a></li><li><a href="/cs-foundations/structures/doubly-linked-list.html">Doubly Linked List</a></li><li><a href="/cs-foundations/structures/skip-list.html">Skip List</a></li><li><a href="/cs-foundations/structures/avl-tree.html">AVL Tree</a></li><li><a href="/cs-foundations/structures/binary-tree.html">Binary Tree</a></li><li><a href="/cs-foundations/structures/adjacency-list.html">Adjacency List</a></li></ul></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Sorting <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="/cs-foundations/sorting/insertion.html">Insertion Sort</a></li><li><a href="/cs-foundations/sorting/selection.html">Selection Sort</a></li><li><a href="/cs-foundations/sorting/merge.html">Merge Sort</a></li><li><a href="/cs-foundations/sorting/heapsort.html">Heapsort</a></li><li><a href="/cs-foundations/sorting/quicksort.html">Quicksort</a></li><li><a href="/cs-foundations/sorting/bubble.html">Bubble Sort</a></li></ul></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Searching <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="/cs-foundations/searching/dfs.html">Depth-First Search (DFS)</a></li><li><a href="/cs-foundations/searching/bfs.html">Breadth-First Search (DFS)</a></li></ul></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Operations <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="/cs-foundations/operations/school-addition.html">School Method for Addition</a></li><li><a href="/cs-foundations/operations/school-multiplication.html">School Method for Multiplication</a></li><li><a href="/cs-foundations/operations/karatsuba.html">Karatsuba Multiplication</a></li></ul></li></ul></div></div></nav><div class="container"><div><h2>Heapsort</h2><p>A comparison based sorting technique based on Binary Heap data structure</p></div><div class="section"><h4>Explanation</h4><p>1. Build a max heap from the input data.</p><p>2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.</p><p>3. Repeat above steps while size of heap is greater than 1.</p></div><div class="section"><h4>Performance</h4><table class="table table-bordered"><thead><tr class="active"><th class="col-xs-3">Operation</th><th class="col-xs-3">Average</th><th class="col-xs-3">Worst</th><th class="col-xs-3">Best</th></tr></thead><tbody><tr><td>Comparisons</td><td>O(n log(n))</td><td>O(n log(n))</td><td>O(n log(n))</td></tr></tbody></table></div><div class="section"><ul class="nav nav-tabs"><li class="active"><a data-toggle="tab" href="#pseudo">Pseudo</a></li><li><a data-toggle="tab" href="#rust">Rust</a></li><li><a data-toggle="tab" href="#js">JavaScript</a></li><li><a data-toggle="tab" href="#cpp">C++</a></li></ul><div class="tab-content"><div class="tab-pane fade in active" id="pseudo"><pre class="code-block"><code>procedure heapsort(a, count) is
    input: an unordered array a of length count
 
    (Build the heap in array a so that largest value is at the root)
    heapify(a, count)
 
    (The following loop maintains the invariants that a[0:end] is a heap and every element
     beyond end is greater than everything before it (so a[end:count] is in sorted order))
    end ← count - 1
    while end > 0 do
        (a[0] is the root and largest value. The swap moves it in front of the sorted elements.)
        swap(a[end], a[0])
        (the heap size is reduced by one)
        end ← end - 1
        (the swap ruined the heap property, so restore it)
        siftDown(a, 0, end)
 
 procedure heapify(a,count) is
     (end is assigned the index of the first (left) child of the root)
     end := 1
     
     while end < count
         (sift up the node at index end to the proper place such that all nodes above
          the end index are in heap order)
         siftUp(a, 0, end)
         end := end + 1
     (after sifting up the last node all nodes are in heap order)
 
 procedure siftUp(a, start, end) is
     input:  start represents the limit of how far up the heap to sift.
                   end is the node to sift up.
     child := end 
     while child > start
         parent := iParent(child)
         if a[parent] < a[child] then (out of max-heap order)
             swap(a[parent], a[child])
             child := parent (repeat to continue sifting up the parent now)
         else
             return</code></pre></div><div class="tab-pane fade in" id="rust"><pre class="code-block"><code>// Part of Cosmos by OpenGenus Foundation
 
fn heapify(arr: &mut [i32], n: usize, i: usize){
    let mut largest = i; //largest as root
    let l = 2*i + 1; //left
    let r = 2*i + 2; //right
 
    //if child larger than root
    if l < n && arr[l as usize] > arr[largest as usize]{
        largest = l;
    }
 
    //if child larger than largest
    if r < n && arr[r as usize] > arr[largest as usize]{
        largest = r;
    }
 
    //if largest is not root
    if largest != i{
        let temp = arr[i as usize];
        arr[i as usize] = arr[largest as usize];
        arr[largest as usize] = temp;
 
        //recursively heapify
        heapify(arr, n, largest);
    }
}
 
fn heap_sort(arr: &mut [i32], n: usize){
    //build heap
    for i in (0..n / 2 - 1).rev(){
        heapify(arr, n, i);
    }
 
    for i in (0..n - 1).rev(){
        //move current root to end
        let temp = arr[i as usize];
        arr[i as usize] = arr[0];
        arr[0] = temp;
 
        heapify(arr, i, 0);
    }
}
 
fn print_array(arr: &mut [i32], n: usize){
    for i in (0..n).rev(){
        print!("{} ", arr[i as usize]);
    }
    println!("");
}
 
//test heap sort
fn main() {
    let mut arr: [i32; 8] = [1, 2, 3, 4, 5, 6, 7, 8];
    let n: usize = arr.len();
 
    heap_sort(&mut arr, n);
 
    println!("Sorted Array:");
    print_array(&mut arr, n);
}</code></pre></div><div class="tab-pane fade in" id="js"><pre class="code-block"><code>/*
* Part of Cosmos by OpenGenus Foundation
*/
 
var arrayLength;
 
function heap_root(inputArray, i) {
	var left = 2 * i + 1;
	var right = 2 * i + 2;
	var max = i;
 
	if (left < arrayLength && inputArray[left] > inputArray[max]) {
		max = left;
	}
 
	if (right < arrayLength && inputArray[right] > inputArray[max]) {
		max = right;
	}
 
	if (max != i) {
		swap(inputArray, i, max);
		heap_root(inputArray, max);
	}
}
 
function swap(inputArray, index_A, index_B) {
	var temp = inputArray[index_A];
 
	inputArray[index_A] = inputArray[index_B];
	inputArray[index_B] = temp;
}
 
function heapSort(inputArray) {
 
	arrayLength = inputArray.length;
 
	for (var i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {
		heap_root(inputArray, i);
	}
 
	for (i = inputArray.length - 1; i > 0; i--) {
		swap(inputArray, 0, i);
		arrayLength--;
		heap_root(inputArray, 0);
	}
}</code></pre></div><div class="tab-pane fade in" id="cpp"><pre class="code-block"><code>/* Part of Cosmos by OpenGenus Foundation */
#include <bits/stdc++.h>
using namespace std;
 
void heapify (vector<int> &v, int n, int i)
{
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
 
    if (l < n && v[l] > v[largest])
        largest = l;
    if (r < n && v[r] > v[largest])
        largest = r;
    if (largest != i)
    {
        swap(v[i], v[largest]);
        heapify(v, n, largest);
    }
}
 
// The heap sort function that should be called
void heap_sort(vector<int> &v)
{
    int n = v.size();
 
    // Build heap (rearrange array)
    for(int i = n / 2 - 1; i >= 0; --i)
        heapify(v, n, i);
    // Extract element from heap 1 by 1
    for(int i = n - 1; i >= 0; --i)
    {
        swap(v[0], v[i]);
        heapify(v, i, 0);
    }
}
 
 
// Testing the heap sort implementation
int main()
{
    vector<int> v = {2, 3, 6, 7, 4, 1};
    heap_sort(v);
    for(int i = 0; i < v.size(); ++i)
    {
        cout << v[i] << " ";
    }	
    return 0;
}</code></pre></div></div></div><div class="section"><script src="/javascripts/sorting/heapsort.js"></script><h4>Demonstration</h4><p>Insert dynamic demo graphics and stuff here</p><script src="/javascripts/demo.js"></script><link rel="stylesheet" href="/stylesheets/demo.css"><form class="form"><div class="form-group"><table class="table table-bordered"><thead><tr class="active"><th colspan="5">Sample Sizes</th></tr></thead><tbody><tr><td class="col-xs-2">Extra Small</td><td class="col-xs-2">Small</td><td class="col-xs-2">Medium</td><td class="col-xs-2">Large</td><td class="col-xs-2">Extra Large</td></tr><tr><td><div class="show" id="xsmallInput"><label for="xsmall" style="width: 100%;"><input id="xsmall" name="xsmall" type="checkbox" checked="true"></label></div><div class="hide" id="xsmallText"></div></td><td><div class="show" id="smallInput"><label for="small" style="width: 100%;"><input id="small" name="small" type="checkbox" checked="true"></label></div><div class="hide" id="smallText"></div></td><td><div class="show" id="mediumInput"><label for="medium" style="width: 100%;"><input id="medium" name="medium" type="checkbox" checked="true"></label></div><div class="hide" id="mediumText"></div></td><td><div class="show" id="largeInput"><label for="large" style="width: 100%;"><input id="large" name="large" type="checkbox" checked="true"></label></div><div class="hide" id="largeText"></div></td><td><div class="show" id="xlargeInput"><label for="xlarge" style="width: 100%; z-index: 10;"><input id="xlarge" name="xlarge" type="checkbox" checked="true"></label></div><div class="hide" id="xlargeText"></div></td></tr></tbody></table></div><div class="form-group" style="text-align: right;"><button class="btn btn-warning" id="reset" type="button" style="margin-right: 1em;" onclick="resetDemo()">Reset</button><button class="btn btn-success" id="submit" type="button" onclick="runAlgo()">Run</button></div></form></div></div></body></html>